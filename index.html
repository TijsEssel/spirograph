<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hypotrochoïde / Epitrochoïde – HTML5 Canvas (Info naast tip)</title>
  <style>
    :root{
      --panel-bg:#f7f7f9;
      --panel-border:#e5e7eb;
      --text:#111827;
      --accent:#2563eb;
      --info-bg:rgba(255,255,255,0.85);
      --gap:12px;
    }
    *{box-sizing:border-box}
    html, body{height:100%}
    body{margin:0; font: 16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, Noto Sans, sans-serif; color:var(--text); background:#fff; display:flex; flex-direction:column;}

    /* --- Top panel above the canvas --- */
    header.panel{position:sticky; top:0; z-index:10; background:var(--panel-bg); border-bottom:1px solid var(--panel-border); padding: max(10px, env(safe-area-inset-top)) var(--gap) 10px var(--gap);}    
    header .title{font-size:1.05rem; font-weight:700; margin:0 0 8px 0}

    /* Controls arranged responsively */
    .controls{display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap:10px var(--gap); align-items:center}
    .ctrl{display:grid; grid-template-columns: 1fr 1fr; gap:8px; align-items:center}
    .ctrl label{font-weight:600; font-size:0.95rem}
    .ctrl input[type="number"]{width:100%; padding:10px 12px; border:1px solid #d1d5db; border-radius:8px; min-height:44px}
    .ctrl input[type="color"]{width:100%; height:44px; padding:0; border:1px solid #d1d5db; border-radius:8px}
    .ctrl input[type="range"]{width:100%}

    .buttons{display:flex; gap:8px; flex-wrap:wrap}
    button{display:inline-flex; align-items:center; gap:6px; cursor:pointer; background:var(--accent); color:white; border:none; border-radius:10px; padding:10px 14px; font-weight:700; min-height:44px}
    button.ghost{background:#e5e7eb; color:#111827}

    /* Tip + info naast elkaar */
    .top-meta{display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap; margin-top:6px}
    .hint{color:#6b7280; font-size:0.9rem; padding:6px 10px; background:transparent; border-radius:8px}
    .info{margin:0; /* <pre> reset */
          background:var(--info-bg); padding:6px 8px; border-radius:8px;
          font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
          font-size:0.8rem; white-space:pre; line-height:1.25}

    /* --- Canvas area --- */
    main.canvas-wrap{ position: relative; display: grid; place-items: center; padding: 10px}
    /* Canvas scales to the screen; internal buffer is set in JS */
    #c{ width: min(95svw, 95svh); height: auto; aspect-ratio: 1 / 1; background: #ffffff; border-radius:10px; box-shadow:0 8px 28px rgba(0,0,0,.08)}
    #warn{position:absolute; left:16px; bottom:16px; background:#ffe9e9; color:#7a0b0b; border:1px solid #f3b9b9; padding:8px 10px; border-radius:8px; display:none}

    @media (min-width: 960px){ header .title{font-size:1.15rem} }
  </style>
</head>
<body>
  <header class="panel" id="topbar">
    <div class="title">Hypotrochoïde / Epitrochoïde</div>
    <div class="controls">
      <div class="ctrl"><label for="R1">R1 </label><input id="R1" type="number" min="1" step="1" value="35"></div>
      <div class="ctrl"><label for="R2">R2 </label><input id="R2" type="text" inputmode="numeric" pattern="-?\d*" autocomplete="off" enterkeyhint="done" value="-12"></div>
      <div class="ctrl"><label for="delta">δ (% van |R2|)</label><input id="delta" type="number" min="0" max="300" step="1" value="75"></div>
      <div class="ctrl"><label for="curveColor">Kleur curve</label><input id="curveColor" type="color" value="#0074D9"></div>
      <div class="ctrl"><label for="bgColor">Achtergrond</label><input id="bgColor" type="color" value="#ffffff"></div>
      <div class="ctrl"><label for="speed">Snelheid</label><input id="speed" type="range" min="1" max="100" step="1" value="35"></div>
      <div class="buttons">
        <button id="playPause">▶︎ Afspelen</button>
        <button id="reset" class="ghost">↺ Reset</button>
      </div>
    </div>
    <div class="top-meta">
      <div class="hint">Tip: R2&lt;0 ⇒ hypotrochoïde; R2&gt;0 ⇒ epitrochoïde.</div>
      <pre id="info" class="info"></pre>
    </div>
  </header>

  <main class="canvas-wrap">
    <canvas id="c"></canvas>
    <div id="warn"></div>
  </main>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const c = $("c");
  const ctx = c.getContext("2d");
  const info = $("info");
  const warn = $("warn");
  const topbar = $("topbar");

  // VisualViewport-aware sizing (mobile friendly)
  function viewportSize(){
    const vv = window.visualViewport;
    if (vv && typeof vv.width === 'number' && typeof vv.height === 'number') {
      return { w: Math.floor(vv.width), h: Math.floor(vv.height) };
    }
    const w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    const h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    return { w, h };
  }

  function sizeCanvas(){
    const {w: vw, h: vh} = viewportSize();
    const headerH = topbar.getBoundingClientRect().height || 0;
    const pad = 10; // same as CSS padding
    const availW = Math.max(160, vw - 2*pad);
    const availH = Math.max(160, vh - headerH - 2*pad);
    const side = Math.max(160, Math.min(availW, availH));
    c.style.width = side + 'px';
    c.style.height = side + 'px';
    setupHiDPI();
  }

  // HiDPI scaling
  function setupHiDPI() {
    const ratio = Math.max(1, window.devicePixelRatio || 1);
    const rect = c.getBoundingClientRect();
    const cssW = Math.max(1, Math.round(rect.width));
    const cssH = Math.max(1, Math.round(rect.height));
    c.width = Math.round(cssW * ratio);
    c.height = Math.round(cssH * ratio);
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
  }

  function bindResizeEvents(){
    const recalc = () => { sizeCanvas(); recompute(); draw(); };
    window.addEventListener('resize', recalc, {passive:true});
    window.addEventListener('orientationchange', recalc, {passive:true});
    window.addEventListener('pageshow', recalc, {passive:true});
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', recalc, {passive:true});
      window.visualViewport.addEventListener('scroll', recalc, {passive:true});
    }
  }

  // Helpers
  const TAU = Math.PI * 2;
  function gcd(a, b){ a = Math.abs(Math.trunc(a)); b = Math.abs(Math.trunc(b)); if(a === 0) return b || 1; while(b){ [a,b] = [b, a % b]; } return a; }

  // Inputs
  const inputs = {
    R1: $("R1"), R2: $("R2"), delta: $("delta"),
    curveColor: $("curveColor"), bgColor: $("bgColor"), speed: $("speed")
  };
  const btnPlay = $("playPause");
  const btnReset = $("reset");

  // Model
  let R1=35, R2=-12, delta=75;
  let curveColor = '#0074D9', bgColor = '#ffffff';
  let running = false;
  let t = 0, tEnd = 0, k = 0, x1 = 0;
  let lastTs = 0;
  let points = []; // trace
  let scale = 1, cx = 0, cy = 0;


function readInt(el, fallback = 0){
  const s = (el.value || "").trim();
  // alleen optioneel '-' + digits
  const m = s.match(/^-?\d+$/);
  return m ? parseInt(s, 10) : fallback;
}

function readInputs(){
  R1 = Math.max(1, readInt(inputs.R1, 1));
  R2 = readInt(inputs.R2, -1);      // <— accepteert nu netjes het minteken
  delta = readInt(inputs.delta, 0);
  curveColor = inputs.curveColor.value || '#0074D9';
  bgColor    = inputs.bgColor.value || '#ffffff';
}


  function recompute(){
    readInputs();
    warn.style.display = 'none';
    if(R2 === 0){
      warn.textContent = 'R2 mag niet 0 zijn.';
      warn.style.display = 'block';
      running = false; btnPlay.textContent = '▶︎ Afspelen';
      draw();
      return;
    }

    const g = gcd(R1, R2);
    const omwentelingen = R2 / g; // kan negatief zijn
    tEnd = Math.abs(omwentelingen) * TAU;
    k = 1 + (R1 / R2);
    x1 = Math.abs(R2) * (delta/100);

    // === Nieuwe, strakke schaal die alles in beeld houdt ===
    // Bereik van de curve: max afstand tot oorsprong is |R1 + R2| + |x1|
    const radialCurve  = Math.abs(R1 + R2) + Math.abs(x1);
    // Grote vaste cirkel heeft straal |R1|
    const radialBig    = Math.abs(R1);
    // Optioneel: ook de rollende cirkel (omtrek) volledig tonen
    const radialRoller = Math.abs(R1 + R2) + Math.abs(R2);

    const radialExtent = Math.max(radialCurve, radialBig, radialRoller) || 1;

    const maxSide = Math.min(c.clientWidth, c.clientHeight);
    const padding = 0.98; // kleine marge zodat er niets klipt
    scale = (padding * maxSide/2) / radialExtent;

    cx = c.clientWidth/2; cy = c.clientHeight/2;

    // Reset animatiestatus
    points = [];
    t = 0; lastTs = 0;
  }

  function worldToCanvas(x, y){ return [cx + x*scale, cy - y*scale]; }

  function speedRadPerSec(){
    const s = +inputs.speed.value; // 1..100
    const durationSec = 33 - (s * 0.3); // ~33..3 s per cyclus
    return (tEnd || 1) / durationSec;
  }

  function update(dt){
    if(!running) return;
    const radPerSec = speedRadPerSec();
    t += radPerSec * dt;
    if(t > tEnd){ t = tEnd; running = false; btnPlay.textContent = '▶︎ Afspelen'; }
  }

  function draw(){
    // Achtergrond
    ctx.save();
    ctx.clearRect(0,0,c.clientWidth, c.clientHeight);
    ctx.fillStyle = bgColor; ctx.fillRect(0,0,c.clientWidth, c.clientHeight);

    // Kwaliteit
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';

    // Huidige posities
    const R1pR2 = R1 + R2;
    const xmR2 = R1pR2 * Math.cos(t);
    const ymR2 = R1pR2 * Math.sin(t);
    const x = (R1pR2) * Math.cos(t) + x1 * Math.cos(k*t);
    const y = (R1pR2) * Math.sin(t) + x1 * Math.sin(k*t);

    // Trace
    points.push([x,y]);

    // Grote cirkel
    ctx.strokeStyle = '#000'; ctx.lineWidth = 1.2;
    ctx.beginPath();
    const [cx0, cy0] = worldToCanvas(0,0);
    ctx.arc(cx0, cy0, Math.abs(R1)*scale, 0, TAU);
    ctx.stroke();

    // Kleine rollende cirkel
    ctx.strokeStyle = '#2ca02c'; ctx.lineWidth = 1.0;
    ctx.beginPath();
    const [cxR2, cyR2] = worldToCanvas(xmR2, ymR2);
    ctx.arc(cxR2, cyR2, Math.abs(R2)*scale, 0, TAU);
    ctx.stroke();

    // Stralen
    ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(cx0, cy0); ctx.lineTo(cxR2, cyR2); ctx.stroke();
    ctx.strokeStyle = '#2ca02c'; ctx.lineWidth = 2; ctx.beginPath(); const [cxi, cyi] = worldToCanvas(x, y); ctx.moveTo(cxR2, cyR2); ctx.lineTo(cxi, cyi); ctx.stroke();

    // Trace tekenen
    ctx.strokeStyle = curveColor; ctx.lineWidth = 1.6;
    ctx.beginPath();
    for(let i=0;i<points.length;i++){
      const [px,py]=worldToCanvas(points[i][0], points[i][1]);
      if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.stroke();

    // Punten
    ctx.fillStyle = '#d62728'; ctx.beginPath(); ctx.arc(cxi, cyi, 4, 0, TAU); ctx.fill();
    ctx.fillStyle = '#2ca02c'; ctx.beginPath(); ctx.arc(cxR2, cyR2, 4, 0, TAU); ctx.fill();

    // Live rotaties (in rot = rad/(2π))
    const n_center = t / TAU; const n_abs = (k * t) / TAU; const n_rel = ((k * t) - t) / TAU;
    info.textContent = `omwentelingen      : ${n_center.toFixed(4)} rot\n`+
                       `relatieve rotaties : ${n_rel.toFixed(4)} rot\n`+
                       `absolute rotaties  : ${n_abs.toFixed(4)} rot`;

    ctx.restore();
  }

  function frame(ts){
    if(!lastTs) lastTs = ts;
    const dt = (ts - lastTs) / 1000; lastTs = ts;
    update(dt); draw();
    requestAnimationFrame(frame);
  }

  // Events
  function onChange(){
    const wasRunning = running;
    recompute(); running = wasRunning; btnPlay.textContent = running ? '❚❚ Pauze' : '▶︎ Afspelen';
  }
  Object.values(inputs).forEach(el => el.addEventListener('input', onChange));
  btnPlay.addEventListener('click', () => { if(R2 === 0) return; running = !running; btnPlay.textContent = running ? '❚❚ Pauze' : '▶︎ Afspelen'; });
  btnReset.addEventListener('click', () => { recompute(); running = false; btnPlay.textContent = '▶︎ Afspelen'; draw(); });

  // Init
  bindResizeEvents();
  sizeCanvas();
  requestAnimationFrame(() => { sizeCanvas(); recompute(); draw(); requestAnimationFrame(frame); });
})();
</script>
</body>
</html>
