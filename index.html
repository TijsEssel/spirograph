<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hypotrochoïde / Epitrochoïde – HTML5 Canvas (Info naast tip)</title>
  <style>
    :root{
      --panel-bg:#f7f7f9;
      --panel-border:#e5e7eb;
      --text:#111827;
      --accent:#2563eb;
      --info-bg:rgba(255,255,255,0.85);
      --gap:10px; /* compacter dan voorheen */
    }
    *{box-sizing:border-box}
    html, body{height:100%}
    body{
      margin:0;
      font: 15px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, Noto Sans, sans-serif;
      color:var(--text);
      background:#fff;
      display:flex; flex-direction:column;
    }

    /* --- Top panel --- */
    header.panel{
      position:sticky; top:0; z-index:10;
      background:var(--panel-bg);
      border-bottom:1px solid var(--panel-border);
      padding: max(8px, env(safe-area-inset-top)) var(--gap) 8px var(--gap);
    }
    header .title{font-size:1.0rem; font-weight:700; margin:0 0 6px 0}

    /* Controls compacter */
    .controls{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap:8px var(--gap); /* compacter */
      align-items:center;
    }
    .ctrl{display:grid; grid-template-columns: 1fr 1fr; gap:6px; align-items:center}
    .ctrl label{font-weight:600; font-size:0.9rem}
    .ctrl input[type="number"]{
      width:100%; padding:6px 8px; border:1px solid #d1d5db; border-radius:6px; min-height:32px; font-size:0.95rem;
    }
    .ctrl input[type="color"]{
      width:100%; height:32px; padding:0; border:1px solid #d1d5db; border-radius:6px;
    }
    .ctrl input[type="range"]{width:100%}

    /* Segmented toggle */
    .segmented { display:inline-flex; border:1px solid #d1d5db; border-radius:8px; overflow:hidden; }
    .segmented .seg {
      background:#f3f4f6; color:#111827; padding:6px 10px; min-height:32px;
      border:0; cursor:pointer; font-weight:600;
    }
    .segmented .seg + .seg { border-left:1px solid #d1d5db; }
    .segmented .seg.active { background: var(--accent); color:#fff; }

    .buttons{display:flex; gap:6px; flex-wrap:wrap}
    button{
      display:inline-flex; align-items:center; gap:6px; cursor:pointer;
      background:var(--accent); color:white; border:none; border-radius:8px;
      padding:8px 12px; font-weight:700; min-height:34px; font-size:0.95rem;
    }
    button.ghost{background:#e5e7eb; color:#111827}

    /* Tip + info */
    .top-meta{display:flex; gap:10px; align-items:flex-start; flex-wrap:wrap; margin-top:6px}
    .hint{color:#6b7280; font-size:0.9rem; padding:4px 8px; background:transparent; border-radius:6px}
    .info{
      margin:0; background:var(--info-bg); padding:6px 8px; border-radius:6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:0.8rem; white-space:pre; line-height:1.25
    }

    /* --- Canvas area --- */
    main.canvas-wrap{ position: relative; display: grid; place-items: center; padding: 8px}
    /* Canvas scales to the screen; internal buffer is set in JS */
    #c{ width: min(95svw, 95svh); height: auto; aspect-ratio: 1 / 1; background: #ffffff; border-radius:10px; box-shadow:0 8px 28px rgba(0,0,0,.08)}
    #warn{position:absolute; left:16px; bottom:16px; background:#ffe9e9; color:#7a0b0b; border:1px solid #f3b9b9; padding:8px 10px; border-radius:8px; display:none}

    @media (min-width: 960px){ header .title{font-size:1.1rem} }
  </style>
</head>
<body>
  <header class="panel" id="topbar">
    <div class="title">Spirograph</div>

    <!-- Nieuw: modus-knoppen -->
    <div class="controls" style="margin-bottom:6px">
      <div class="segmented" role="group" aria-label="Type curve">
        <button id="btnHypo" class="seg" type="button" aria-pressed="false">Hypotrochoïde</button>
        <button id="btnEpi" class="seg" type="button" aria-pressed="false">Epitrochoïde</button>
      </div>
    </div>

    <div class="controls">
      <div class="ctrl"><label for="R1">R1 (natuurlijk)</label><input id="R1" type="number" min="1" step="1" value="35"></div>
      <div class="ctrl"><label for="R2">R2 (geheel)</label><input id="R2" type="number" step="1" value="-12"></div>
      <div class="ctrl"><label for="delta">δ (% van R2)</label><input id="delta" type="number" min="0" max="300" step="1" value="75"></div>
      <div class="ctrl"><label for="curveColor">Kleur curve</label><input id="curveColor" type="color" value="#0074D9"></div>
      <div class="ctrl"><label for="bgColor">Achtergrond</label><input id="bgColor" type="color" value="#ffffff"></div>
      <div class="ctrl"><label for="speed">Snelheid</label><input id="speed" type="range" min="1" max="100" step="1" value="35"></div>
      <div class="buttons">
        <button id="playPause">▶︎ Afspelen</button>
        <button id="reset" class="ghost">↺ Reset</button>
      </div>
    </div>


  </header>

  <main class="canvas-wrap">
    <canvas id="c"></canvas>
    <div id="warn"></div>
  </main>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const c = $("c");
  const ctx = c.getContext("2d");
  const info = $("info");
  const warn = $("warn");
  const topbar = $("topbar");

  // VisualViewport-aware sizing (mobile friendly)
  function viewportSize(){
    const vv = window.visualViewport;
    if (vv && typeof vv.width === 'number' && typeof vv.height === 'number') {
      return { w: Math.floor(vv.width), h: Math.floor(vv.height) };
    }
    const w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    const h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    return { w, h };
  }
  function sizeCanvas(){
    const {w: vw, h: vh} = viewportSize();
    const headerH = topbar.getBoundingClientRect().height || 0;
    const pad = 8; // same as CSS padding
    const availW = Math.max(160, vw - 2*pad);
    const availH = Math.max(160, vh - headerH - 2*pad);
    const side = Math.max(160, Math.min(availW, availH));
    c.style.width = side + 'px';
    c.style.height = side + 'px';
    setupHiDPI();
  }
  // HiDPI scaling
  function setupHiDPI() {
    const ratio = Math.max(1, window.devicePixelRatio || 1);
    const rect = c.getBoundingClientRect();
    const cssW = Math.max(1, Math.round(rect.width));
    const cssH = Math.max(1, Math.round(rect.height));
    c.width = Math.round(cssW * ratio);
    c.height = Math.round(cssH * ratio);
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
  }
  function bindResizeEvents(){
    const recalc = () => { sizeCanvas(); recompute(); draw(); };
    window.addEventListener('resize', recalc, {passive:true});
    window.addEventListener('orientationchange', recalc, {passive:true});
    window.addEventListener('pageshow', recalc, {passive:true});
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', recalc, {passive:true});
      window.visualViewport.addEventListener('scroll', recalc, {passive:true});
    }
  }

  // Helpers
  const TAU = Math.PI * 2;
  function gcd(a, b){ a = Math.abs(Math.trunc(a)); b = Math.abs(Math.trunc(b)); if(a === 0) return b || 1; while(b){ [a,b] = [b, a % b]; } return a; }

  // Inputs
  const inputs = {
    R1: $("R1"), R2: $("R2"), delta: $("delta"),
    curveColor: $("curveColor"), bgColor: $("bgColor"), speed: $("speed")
  };
  const btnPlay = $("playPause");
  const btnReset = $("reset");

  // Nieuw: mode toggle buttons
  const btnHypo = $("btnHypo");
  const btnEpi  = $("btnEpi");

  function setModeButtons(sign){
    const hypoActive = sign < 0;
    btnHypo.classList.toggle('active', hypoActive);
    btnEpi.classList.toggle('active', !hypoActive);
    btnHypo.setAttribute('aria-pressed', hypoActive ? 'true' : 'false');
    btnEpi.setAttribute('aria-pressed', hypoActive ? 'false' : 'true');
  }
  function setR2Sign(sign){
    let v = Math.abs(parseInt(inputs.R2.value, 10));
    if (!v) v = 1; // vermijd 0
    inputs.R2.value = sign < 0 ? -v : v;
    setModeButtons(sign);
    onChange();
  }
  btnHypo.addEventListener('click', () => setR2Sign(-1));
  btnEpi .addEventListener('click', () => setR2Sign( 1));

  // Model
  let R1=35, R2=-12, delta=75;
  let curveColor = '#0074D9', bgColor = '#ffffff';
  let running = false;
  let t = 0, tEnd = 0, k = 0, x1 = 0;
  let lastTs = 0;
  let points = []; // trace
  let scale = 1, cx = 0, cy = 0;

  function readInputs(){
    R1 = Math.max(1, Math.trunc(+inputs.R1.value || 1));
    R2 = Math.trunc(+inputs.R2.value || -1);
    delta = +inputs.delta.value || 0;
    curveColor = inputs.curveColor.value || '#0074D9';
    bgColor = inputs.bgColor.value || '#ffffff';
  }

  function recompute(){
    readInputs();
    warn.style.display = 'none';
    if(R2 === 0){
      warn.textContent = 'R2 mag niet 0 zijn.';
      warn.style.display = 'block';
      running = false; btnPlay.textContent = '▶︎ Afspelen';
      draw();
      return;
    }
    const g = gcd(R1, R2);
    const omwentelingen = R2 / g; // kan negatief zijn
    tEnd = Math.abs(omwentelingen) * TAU;
    k = 1 + (R1 / R2);
    x1 = Math.abs(R2) * (delta/100);

    // Strakke schaal die alles in beeld houdt
    const radialCurve = Math.abs(R1 + R2) + Math.abs(x1);
    const radialBig   = Math.abs(R1);
    const radialRoller= Math.abs(R1 + R2) + Math.abs(R2);
    const radialExtent= Math.max(radialCurve, radialBig, radialRoller) || 1;
    const maxSide = Math.min(c.clientWidth, c.clientHeight);
    const padding = 0.98;
    scale = (padding * maxSide/2) / radialExtent;
    cx = c.clientWidth/2; cy = c.clientHeight/2;

    // Reset animatiestatus
    points = [];
    t = 0; lastTs = 0;

    // Zorg dat de modusknoppen overeenkomen met het teken van R2
    setModeButtons(Math.sign(R2));
  }

  function worldToCanvas(x, y){ return [cx + x*scale, cy - y*scale]; }
  function speedRadPerSec(){
    const s = +inputs.speed.value; // 1..100
    const durationSec = 33 - (s * 0.3); // ~33..3 s per cyclus
    return (tEnd || 1) / durationSec;
  }
  function update(dt){
    if(!running) return;
    const radPerSec = speedRadPerSec();
    t += radPerSec * dt;
    if(t > tEnd){ t = tEnd; running = false; btnPlay.textContent = '▶︎ Afspelen'; }
  }
  function draw(){
    // Achtergrond
    ctx.save();
    ctx.clearRect(0,0,c.clientWidth, c.clientHeight);
    ctx.fillStyle = bgColor; ctx.fillRect(0,0,c.clientWidth, c.clientHeight);

    // Kwaliteit
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';

    // Huidige posities
    const R1pR2 = R1 + R2;
    const xmR2 = R1pR2 * Math.cos(t);
    const ymR2 = R1pR2 * Math.sin(t);
    const x = (R1pR2) * Math.cos(t) + x1 * Math.cos(k*t);
    const y = (R1pR2) * Math.sin(t) + x1 * Math.sin(k*t);

    // Trace
    points.push([x,y]);

    // Grote cirkel
    ctx.strokeStyle = '#000'; ctx.lineWidth = 1.2;
    ctx.beginPath();
    const [cx0, cy0] = worldToCanvas(0,0);
    ctx.arc(cx0, cy0, Math.abs(R1)*scale, 0, TAU);
    ctx.stroke();

    // Kleine rollende cirkel
    ctx.strokeStyle = '#2ca02c'; ctx.lineWidth = 1.0;
    ctx.beginPath();
    const [cxR2, cyR2] = worldToCanvas(xmR2, ymR2);
    ctx.arc(cxR2, cyR2, Math.abs(R2)*scale, 0, TAU);
    ctx.stroke();

    // Stralen
    ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(cx0, cy0); ctx.lineTo(cxR2, cyR2); ctx.stroke();
    ctx.strokeStyle = '#2ca02c'; ctx.lineWidth = 2; ctx.beginPath(); const [cxi, cyi] = worldToCanvas(x, y); ctx.moveTo(cxR2, cyR2); ctx.lineTo(cxi, cyi); ctx.stroke();

    // Trace tekenen
    ctx.strokeStyle = curveColor; ctx.lineWidth = 1.6;
    ctx.beginPath();
    for(let i=0;i<points.length;i++){
      const [px,py]=worldToCanvas(points[i][0], points[i][1]);
      if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.stroke();

    // Punten
    ctx.fillStyle = '#d62728'; ctx.beginPath(); ctx.arc(cxi, cyi, 4, 0, TAU); ctx.fill();
    ctx.fillStyle = '#2ca02c'; ctx.beginPath(); ctx.arc(cxR2, cyR2, 4, 0, TAU); ctx.fill();

    // Live rotaties (in rotations = rad/(2π))
    const n_center = t / TAU; const n_abs = (k * t) / TAU; const n_rel = ((k * t) - t) / TAU;
    info.textContent = `omwentelingen : ${n_center.toFixed(2)} rot\n`+
                       `relatieve rotaties : ${n_rel.toFixed(2)} rot\n`+
                       `absolute rotaties : ${n_abs.toFixed(2)} rot`;
    ctx.restore();
  }

  function frame(ts){
    if(!lastTs) lastTs = ts;
    const dt = (ts - lastTs) / 1000; lastTs = ts;
    update(dt); draw();
    requestAnimationFrame(frame);
  }

  // Events
  function onChange(){
    const wasRunning = running;
    recompute(); running = wasRunning; btnPlay.textContent = running ? '❚❚ Pauze' : '▶︎ Afspelen';
  }
  Object.values(inputs).forEach(el => el.addEventListener('input', onChange));
  // Als R2 handmatig wordt aangepast, pas de modusknoppen aan
  inputs.R2.addEventListener('input', () => setModeButtons(Math.sign(+inputs.R2.value || -1)));

  btnPlay.addEventListener('click', () => { if(R2 === 0) return; running = !running; btnPlay.textContent = running ? '❚❚ Pauze' : '▶︎ Afspelen'; });
  btnReset.addEventListener('click', () => { recompute(); running = false; btnPlay.textContent = '▶︎ Afspelen'; draw(); });

  // Init
  bindResizeEvents();
  sizeCanvas();
  // Initiale modus-knoppen toestand obv beginsituatie (R2 = -12)
  setModeButtons(-1);
  requestAnimationFrame(() => { sizeCanvas(); recompute(); draw(); requestAnimationFrame(frame); });
})();
</script>
</body>
</html>
